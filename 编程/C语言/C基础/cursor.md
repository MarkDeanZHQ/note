# 2022-02-11cursor
            

# 内存

## 内存含义：

l 存储器：计算机的组成中，用来存储程序和数据，辅助CPU进行运算处理的重要部分。

l 内存：内部存贮器，暂存程序/数据——掉电丢失 SRAM、DRAM、DDR、DDR3、DDR3。

l 外存：外部存储器，长时间保存程序/数据—掉电不丢ROM、ERRROM、FLASH（NAND、NOR）、硬盘、光盘。

内存是沟通CPU与硬盘的桥梁：

l 暂存放CPU中的运算数据

l 暂存与硬盘等外部存储器交换的数据

## 物理存储器和存储地址空间

有关内存的两个概念：物理存储器和存储地址空间。

物理存储器：实际存在的具体存储器芯片。

l 主板上装插的内存条

l 显示卡上的显示RAM芯片

l 各种适配卡上的RAM芯片和ROM芯片

存储地址空间：对存储器编码的范围。我们在软件上常说的内存是指这一层含义。

l 编码：对每个物理存储单元（一个字节）分配一个号码

l 寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写

## 内存地址

l 将内存抽象成一个很大的一维字符数组。

l 编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关）。

l 这个内存编号我们称之为内存地址。

内存中的每一个数据都会分配相应的地址：

l char:占一个字节分配一个地址

l int: 占四个字节分配四个地址

l float、struct、函数、数组等





# 内存与指针
指针==地址==编号

## 指针变量
用来存地址(指针)的变量
32位编译器  地址编号(0x0000 0000)  指针变量占4个字节
64位编译器  地址编号(0x0000 0000 0000 0000) 指针变量占8个字节

## **定义指针三步骤**
1. *与符号结合代表的是一个指针变量
2. 要保存谁的地址，将他的定义形式放在此处
3. 用\*p替换掉定义的变量
int \*p;
## 分析指针三步骤
1. 与*结合代表这是一个指针变量
2. p是变量，p的类型是将变量p本身拖黑，剩下的类型就是指针变量的类型  int\*
3. 剩下什么类型就保存什么类型数据的地址




## 指针的宽度和步长
1. 通过*取指针变量所指向空间内容时，取的内存的宽度和指针变量本身类型有关
2. 当*指针类型 取的内存宽度大于该类型时，会从低位往高位取。
3. 指针步长 ： 指针加1 跨过的字节

| 指针类型  | 宽度(字节) |
| :------: | :--------: |
| char \*  |     1      |
| short \* |     2      |
|  int \*  |     4      |
|  \*\*p   |     4      |



# 指针
## 野指针
* 未定义的指针
* 指向随机
* 不可操作
* 指针存的地址必须是空余的、向系统申请过的
    * 手写的地址、占用其他内存空间的地址均不可用 
    


## 空指针
* 含义：将指针赋值为 NULL （0x0000 0000），该地址为系统初始化地址，不可操作。
* 用途：编程习惯。在指针使用完后，将其赋值为NULL，方便后续使用时通过判断是否为NULL，得知该指针是否空余。



## 万能指针
* 含义：使用 void 来定义指针。
    * void 为空类型，不可用来定义变量数据类型，可以用来定义指针，因为指针的大小为 4 字节(已知)。
    * 万能指针可 存放 任意类型的指针。
    * 存放和使用时，需要 转换指针类型，告诉系统需要使用的空间大小。
        * 存放 ：void \*p = (void \*)&a;
        * 使用 ：printf("%d",* (int *)p);
* 用途：用以存放 任意类型的指针。
* 取地址的内存空间的大小 与 数据类型有关




## const 修饰
>**int * p;**
* 修饰 int ：不可通过变量 改值，可通过指针指向该空间 改值。  —— 变量，非指针
* 修饰 * ：不可修改指针指向空间。   —— const int * p
* 修饰 p ：不可修改指针的指向地址。 —— int * const p;

## 多级指针
>指针存放的是 内存的地址
>多级指针 即为  存放地址 的地址，亦为 指向指针地址的指针
* 星花数 代表 取地址次数
* 保存 n 级 指针，只需用 n+1 个星花来存放
* 数据类型  即为 除去 取得的数据后 剩下的类型 



## 数组 指针
* <details><summary>元素加一 ，跨一个元素</summary><p>a + 1 || &a[0] + 1 </p></details>
* <details><summary>数组加一，跨一个数组</summary><p>&a + 1</p></details>



 
## 指针运算
* 前提：相同数据类型的指针
* 相减：得出指针间的步长
* 相加没有意义

## []的运用
* p[0] == *(p + 0);
* [] 并非数组专用




## 数组指针
* <details><summary>数组指针的含义</summary><p>用来存放系列变量地址的指针</p>
* <details><summary>数组指针类型</summary><p>int * a[10] ：类型为 int * [10]   //类型反应大小</p>
* <details><summary>数组指针的运用</summary><p>可以批量通过指针改变量</p>




## 形参改变实参
**传入指针，通过寻址改变实参**


## 数组作为函数参数
* 在函数中
    * 一个[] 代表一个\*
    * 无法直接知道是否为数组指针，因而无法知道数组的元素数量。
    *  可以设置 传递数组的数量的参数 ，从而批量处理数组。
    

## 指针作为函数的返回值
* {}中的是局部变量，函数结束时释放。
* 函数外的是全局变量，程序结束时释放。
* 函数返回值 需要使用 全局变量。否则会导致其他空间被更改。




## 函数的运用
* 函数的调用  func();
* 函数的原型说明 int func();
* 函数定义  int func(){};




## 字符指针数组
* [] == *()
    * [n] == *(+n);
    * [][] == \*(\*());

* 字符串中取字符 ，因为字符串为地址，需要 * 取指向空间内容    。

>例如 ：
char \*a[]={"acb","def","ghij"};
char \*\*b = a;
使用 二级指针 b 改 a 中字符串的字符 ，可近似认为是二维数组。
* 修改"def"中的 e ，b[1][1]='x';   ==   \*(*(b+1)+1)='x';





## 字符指针数组作为 main 函数的参数
```c
int mian(int a,char *b[])  // a 为传入字符指针数组元素参数个数，默认为 1 （运行路径); b 为传入的字符指针数组。
{}
```
> 设定传入参数方法：
* vs中，在属性页-调试-命令参数。  不同参数用空格隔开
* gcc中，直接添加在命令最后。




## 字符串处理
