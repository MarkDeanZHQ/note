# 继承
回顾：
C++ 三大特性
1. 封装
    1. 权限
    2. 封装数据在类内
2. 继承
    1. 代码复用
    2. 扩展功能
3. 多态


小测试：
继承作用 1.____   2.____
继承三大方式 1.____   2.____  3.____


继承方式对应的 子类访问权限、子类使用权限
公有继承
|父类权限|子类权限|
|---|---|---|
|公有|公有|
|私有|私有|
|保护|保护|

保护继承
|父类权限|子类权限|
|---|---|---|
|公有|保护|
|私有|私有|
|保护|保护|


私有继承
|父类权限|子类权限|
|---|---|---|
|公有|保护|
|私有|私有|
|保护|私有|

总结：
1. 公有继承，保留父类所有权限
2. 私有继承，所有变私有
3. 保护继承，公有权限变保护。其余不变。

按隐私等级理解：
1. 公有继承，0级 保留原有权限
2. 保护继承，1级 不允许外部访问
3. 私有继承，2级 不允许继承访问

## 继承对象模型
名词补给站：
1. 派生类  —— 子类 由父类派生出来
2. 基类 —— 派生类 基于 父类 派生

方法：菜单-developer vs-进入工程文件夹
      使用命令：cl/d1 reportSingleClassLayout类名 文件名.cpp
      


### 注意点
子类继承父类，不能访问的私有属性 也继承过来了，由语法规定，只是不能访问


## 继承中的构造和析构的调用
类中构造、析构的调用对象有：父类、成员对象、自己、父类的父类、父类的成员对象
构造调用顺序：
1. 父类
2. 成员对象
3. 自己

析构反之


调用顺序的作用：
调用顺序可以让我们知道，编译器调用这个函数需要哪些条件
即创建该成员对象的前提是 父类、成员对象、自己的析构函数 必须能够被调用


## 继承中 存在同名成员情况
约定：
1. 优先访问子类 同名成员
2. 父类同名成员、同名函数及重载函数 隐藏

访问同名父类方法：
加上在该同名成员前加上 父类名::

例：son.father::func();

### 静态成员特性
静态成员函数不能是虚函数

### 不能被继承的函数
1. 四大初始函数：构造、拷构、析构、赋值
2. 赋值运算符重载函数


### 多继承
继承两个以上的父类

使用方式：用逗号隔开，写上 继承方式和父类名 

例：class Son :public Father, public Mother