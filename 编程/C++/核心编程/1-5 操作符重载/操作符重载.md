# 操作符重载
本质：实现的具体步骤封装成函数
原理：把类、对象的运算符 重定义调用函数
实际意义：在现有对象的基础上，抽象、重新组成、构造 一个不同状态的对象。
运用：对 两个对象 进行运算，得到第三个对象。

关键词 operator[+,-,*,/]\()  —— 作为函数定义标识符
- 返回值类型，为计算结果的类型
- 返回局部对象，会进行拷贝构造


加减乘除，是双目运算符

两种方式    ——    全局方式、成员函数方式
- 全局方式，传入两个运算对象
    - 第一个参数是左值
    - 第二个参数是右值
- 成员函数方式
    - 第一个参数是右值
    - 左值是本身对象,就是this
    
## 运算符重载
不能重载的符号  1 . 2 :: 3 .* 4 sizeof

![](vx_images/322224118238894.png)


## 继承特性：
除了赋值号(=)外，基类中被重载的操作符都将被派生类继承。

## 特殊运算符
    1. =, [], () 和 -> 操作符只能通过成员函数进行重载 
	2. << 和 >> 操作符最好通过友元函数进行重载
	3. 不要重载 && 和 || 操作符，因为无法实现短路规则

常规建议
![](vx_images/437974718226761.png)


理解技巧：站在 编译器 为程序员服务为的角度思考


# 左移,右移运算符重载

## 左移运算符重载
本质：调用 运算符重载函数
原理：结合 函数重载、返回值类型，以运算符重载的方式，实现左移打印
实际意义：可以更加灵活、更加宏观的把握 运算符的思想，将其与实物相结合，根据实际情况，对应出不同的运算含义。
运用：把握对象特定特征 变化的规律，对该规律 运算符化。

左移运算符重载
1. cout 是 ostream 的对象，<< 是左移运算符
2. 约定 重载左移运算符 是为了打印
3. 不能改变库类中的代码
4. ostream 把构造函数私有化了

操作符重载 遇上 endl 
5. endl 是一个函数，返回值为函数指针
6. ostream的对象有 函数重载处理函数指针；
7. 使用endl，需要返回 ostram 对象

操作符重载 遇上 友元函数
8. 操作符重载函数中 需要调用 私有成员时, 在类中 声明友元

使用手册：
1. 返回iostream引用
2. 双目运算符
3. 第一个参数填 iostream

## 右移运算符
本质：调用函数
原理：将scanf 获取输入，用运算符重载给 >> 

使用注意：
1. 关键字 cin
2. 将数输入给变量 
3. 例:  cin>> a >> b     — 从输入 分别给 a,b 赋值

## 赋值运算符重载
本质：将右边的值，赋给左边的值，保留原来的寓意。
原理：自定义赋值操作规则，达到深拷贝，从里到外一样。
实际意义：成为目标，前提要有自我(空间)，而不只是活成别人的样子(地址)。
运用：涉及到堆区空间赋值时，进行赋值运算符重载，做到深拷贝，且保留运算符原有寓意。

赋值运算符寓意：将右值赋值给左值，返回左值本身空间。

实际问题：
1. 简单赋值，会发生空间的二次释放和内存泄露。
2. (m1=m2)=m3    做到 m2赋值给m1后，讲m3赋值给m1.

方案：
1. 释放原来空间，创建新的空间进行拷贝内容
2. 返回this引用，使返回值可以操作当前对象。


## 关系运算符（了解）
返回值为 bool类型


## 前置加加、后置加加
前置加加：进行运算后，返回引用


重点：后置加加
思想：
创建临时对象 拷贝当前对象，运算当前对象，返回临时对象

注意两点：1. 返回对象为拷贝对象，不引用
            2. 约定占位参数为 int
            

## 数组下标重载
问题：
1. 实现对象和数组一样，可以通过数组下标进行批量操作。
2. 用数组下标进行赋值时，更新数组大小。

解决方案：
1. 对[]符号进行重载，返回对应下标可充当左右值的成员数组元素。
2. 通过数组下标调用时，判断满足 下标大于等于 元素大小时，元素大小加一。

举一反三
2. 成员运算符=重载，在给数组赋值时，判断满足 下标大于等于 元素大小时，元素大小加一。
    - 注意点：通过 数组元素地址 相减 获取下标。
    

## 运算符重载小结
- \+ 将两个对象相加
- << 打印对象
- \>> 输入对象
    - 左对象类为  iostream
- [] 批量操作对象
- ++ 给对象的成员属性增量
    - 后置 ++ ：占位符int，返回临时对象
- == 判断对象属性


建议：同条件下，尽量使用前置加加，后置加加会产生新对象


# 其他重载与智能指针

## 智能指针
说白了，创建类 delete 其他类对象
防止别人忘记释放对象，帮其释放对象而存在
约定类名：SmartPoint

### 重载指针成员选择符 ->
本质：运算符重载 返回对象指针

注意：
1. 编译器将该 运算符重载优化，自动给返回指针添加 ->
2. 进行重载的类中，存有目标类对象指针 的成员属性。

### 重载取值运算符 *
本质：运算符重载 返回另一个对象的引用

注意：
1. * 的运算符优先级低于 成员选择 -> 和 .   需要将*和对象 括起来





## 仿函数
本质：对象调用成员函数
原理：对象通过运算符重载 调用函数
实际意义：一个人既可以找棍棒等武器攻击，也可以用拳头攻击。
运用：使对象本身成为一个函数，既可以当函数，也是个对象

仿函数定义：类内有重载函数调用符号()de, 实例化的函数叫 仿函数。

使用手册：
1. 重载符号();
2. 返回 void


好处：
1. 方便代码维护   |  减少了代码块
2. 进行权限管理
3. 作为算法策略


## 其他重载

### 重载对象 bool 属性
本质：定义对象的 bool属性

使用手册：
1. 没有返回值
2. 没有参数
3. 返回 真假
例子：
```cpp
operator bool()
{
    if(...)
    {
        return false;
    }
    return true;
}
```

### 重载非 ! 运算符
快速入门：与单目运算符++, -- 相同

使用手册：
1. 返回值 bool

### 重载 类型转换
本质：对类型强转符号 进行重载

使用手册：
1. 重载符号为 类型
2. 返回值无要求、尽量与重载类型相同
例子：
```cpp
class TypeT
public:
    operator int()
    {
        return 10;
    }
    
int main()
{
    TypeT x;
    int a = (int)x;
    cout << a << endl;   //输出 10；
}
```

## 堆区空间 需要重新开辟、拷贝数据小技巧
先开辟堆区空间，将数据拷贝进去，然后重新开辟，更改指针

本质：更改指针
原理：利用指针，使临时指针空间 与要开辟的指针空间同步。
实际意义：提前准备好礼物，人一就位，就送到。
运用：节省堆区、栈区的资源，将临时变量变为目标变量。