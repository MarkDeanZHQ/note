# 遗忘点
封装：
1. 给数据权限
2. 封装数据

继承：
1. 代码复用
2. 功能扩展

多态：
1. 同一操作，作用不同对象，有不同解释，产生不同效果。


## 说到类型 要立刻想到 读取的内存大小

默认参数二点
1. 默认参数后，均为默认参数
2. 声明函数和 实现函数中的默认参数 只能存在一个地方

占位参数：
1. 运算符前加加重载 区分后加加

拷贝构造隐式调用两种方式
1. 返回对象
2. obj1 =obj2

初始化列表 —— 传入初始化值：
class():obj(),obj()

explicit   禁用优化 class obj=val;

delete[]

静态成员：
1. 归属 是类
2. 初始化  类外
静态函数 无this指针

对象模型：成员变量、成员函数存储位置区分开

常函数：func()const
常函数可修改值：mutable关键字
常对象   const class obj(); 两不可，两可
- 不可修改成变
- 不可调用成函
- 可调用常函
- 可修改mutable

友元：破坏类的封装

单例模式：只能有一个对象
- 私有构造、拷贝构造
- 静态函数返回静态对象
- 私有静态对象
- 类外初始静对 ：class* class::val = new class;

静态继承：
- 静函不能是 虚函数
- 改变子类静成，父类也改变

动态联编是多态实现的基础
动态联编使用关键字：virtural
动态联编 —— 使用晚绑定，禁用静态联编

虚析构函数 —— 原理 ：
使用动态联编的晚绑定法，绑定指针指向空间的函数入口；
而不是静态联编绑定父类的析构函数入口。

纯虚析构函数：
- 类外实现：class::~class(){}

