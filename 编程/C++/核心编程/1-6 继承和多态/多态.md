# 多态
子类本质： 继承父类、扩展父类。在父类的内存空间上、扩展空间。
类型本质：取内存空间的大小。

多态本质：取父类类型空间(父类部分空间)。
多态原理：通过virtual关键字，重绑定父类空间同名函数入口地址。
多态实际意义：动物有的特性，动物中每个种类都有。植物有的特性，每种植物都有。人有的特性，每个职业都有。在大的前提特性下，衍生出不同的功能。
多态运用：使父类的派生类，拥有各种各样的形态，并且展现这些形态不需要写额外的函数，在父类大的特性之下，可以直接调用。



对象：可转换类型(适应类型范围)   ——  子类可向上转换父类
适用不同对象

作用：可调用类型同名函数名     ——    同名函数加上 virtual关键字
产生不同效果



解决问题：节省代码，低耦合
1. 解决项目中的紧耦合问题，提供程序的可扩展性。
2. 不必为每一个子类的功能调用编写代码，只需对抽象的父类进行处理。

使用手册：
1. 面向派生类
2. 重写父类的虚函数
3. 基类指针 指向派生类对象
使得 派生类虚函数 适用一切 调用 基类指针形参的函数。



### 指针调用函数
找存目标指针的地址，通过该指针找到指针函数的地址，调用函数指针地址实现函数。


## 多态的实现原理
虚函数表指针 指向表内容实现
与虚继承表指向不同

虚函数表指针特性：
1. 指向一块表
2. 指针属于类，表空间不属于类
3. 继承过来的虚函数表指针，在构造函数中初始化指向同一张表
4. 存放所有虚函数指针 的入口地址
5. 重写了父类的虚函数，会覆盖掉对应父类的函数入口地址。
6. 占类一个指针空间大小


调用的时候，父类指针指向 子类对象空间。
调用的 是子类空间的虚函数表指针，指向子类虚函数入口地址。




## 纯虚函数和抽象类
编程时分为：业务层、实现层、抽象层
业务层是业务进行的地方，要有强稳定性，不允许经常修改代码。
实现层是实现功能的地方，常进行代码的实现和修改。
抽象层隔开业务层和实现层，业务层和实现层通过抽象层交互，实现了对修改原代码关闭，对扩展新功能开放。

依赖倒转：业务层依赖抽象层，实现层依赖业务层。

业务层：函数调用区；
实现层：函数功能实现区；
抽象层：抽象类区； —— 功能调用接口

抽象类：
1. 含有纯虚函数的类
2. 不能实例化对象
3. 没有实现所有父类纯虚函数的子类

纯虚函数：
1. 不写实现体的虚函数
2. 例：virtual int getnum(int a, int b)=0;


### 接口定义
抽象层：接口的声明
实现层：接口的实现
业务层：接口的调用

定义：将内部实现细节封装起来，外部用户用预留的接口可以使用接口的功能而不需要知道内部具体细节。C++中，通过类实现面向对象的编程，而在基类中只给出纯虚函数的声明，然后在派生类中实现纯虚函数的具体定义的方式，实现接口，不同派生类实现接口的方式也不尽相同。

## 模板方法模式
在抽象类中，提供函数，确定好函数调用顺序。


## 虚析构函数和 纯虚析构函数
虚析构函数：基类函数指针指向 派生类对象时，释放空间调用派生类析构函数。
纯虚析构函数：
1. 以纯虚函数 写基类析构函数
2. 在类外写 纯虚析构函数的实现
3. 使类不能创建对象，成为抽象类


问题：
```cpp
void test()
{
    Animal* animal = new Son;
    delete animal;
}
```
无法调用子类析构函数的原因：
调用顺序
1. 创建子类对象
2. 构造函数调用顺序：父类、成员对象、自己
3. 释放空间： 由静态联编，animal 析构函数绑定父类析构函数
ps：子类析构，会自动调用父类析构。

虚析构函数可以调用子类的原因：
1. 虚函数表中，替换了父类的虚析构函数。
2. 调用时，通过虚函数表进入 子类析构函数调用入口。

使用手册：
1. 只需在父类写 虚析构函数/纯虚析构函数



## 重写，重载，重定义 小结
重写：
- 用虚函数重写 基类虚函数
- 覆盖特性

重载：
- 同一作用域的同名函数
- 适用特性

重定义：
- 基类 非virtual函数 定义基类的同名成员
- 隐藏特性

## 父类引用子类对象
基类指针 指向虚继承子类对象，不能释放空间

父类引用子类对象：
例如：Animal &dog = new Dog();
Animal* &an = dog;  // an 是 Animal* 类型
Animal &an = *dog;  // an 是 Animal 类型

# 指针类型    ——  个人总结
两种类型  
1. 指向数据的类型  ——  一级指针类型   步长为数据类型大小
2. 指向指针的类型  ——  多级指针类型   步长为指针大小