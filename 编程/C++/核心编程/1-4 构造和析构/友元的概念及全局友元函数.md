# 友元的概念及全局友元函数
本质：权限赋予，增加判断允许访问的 if条件
原理：通过在类内声明 可以访问私有成员的条件
实际意义：使得 某些特权函数、类、成员函数 可以访问类的私有成员
运用：赋予对象特权时，使用此友元，实现授权



思想：生活中，客厅是 客人都可以来的，卧室是 不允许客人随意进入的。但也有例外 —— 好基友、闺蜜、家人等。 此时引入友元概念 ，赋予特权 使之可以进入。

使用方式：类内 friend修饰 声明 
关键字firend + 函数/类声明
friend目标：全局函数、成员函数、类

注意：友元函数 只是声明赋予特权，不是成员函数 。不带 this指针

特权：可访问对象任意成员属性，包括私有属性



## 两种访问私有成员方式
1. 通过传入参数来访问类的私有成员


2. 通过类内指针来访问私有成员    **注意**
指针开辟空间，析构函数释放空间，避免多次释放同一地址，需要写拷贝构造 深拷贝。



## 类的成员函数成为 友元函数
需要在前面声明类  和类的结构

例：
```cpp
class Builing; // 声明类
class GoodGay
{
public:
    void func(Building &bud);  //成员函数的声明
}
```

声明类的成员函数 格式： 关键字friend + 返回值类型 + 类名 + 作用域符号:: + 函数();
例:     friend void GoodGay::func(Building &bud);

原因
1. 编译器知道类的声明，不知道类的结构



## 友元类注意项
1. 友元关系不能被继承
2. 友元关系是单向的     ： 例：A让B进房间，B不让A进房间 
3. 友元关系不具有传递性。           例：朋友的朋友，不一定是我的朋友


## 防止空指针调用成员函数
在成员函数中，解决空指针调用成员函数    ：加入if判断是否为空   
```cpp
class Maker
{
public:
    Maker()
    {
        a=20;
    }
    
    void printMaker()
    {
        if(this==NULL)
        {
            cout<<"this==NULL"<<endl;
            return;
        }
        
        cout<<this->a<<endl;
    }
    
private:
    int a;
};
```


# 单例模式的实现
本质：访问一个静态成员对象
原理：私有化构造、析构，使不能创建对象；提供静态成员对象
实际意义：一个只用到一个对象的类；避免不必要的浪费，使具有唯一性
运用：一个功能，对应一个窗口的时候。

**初始化静态成员需要加上 数据类型**

单例模式 概念： windows 任务管理器 只能打开一个。使功能相同的对象 只能存在一个，避免重复。 
思路：
1. 要使类 只能创建一个
2. 使类 不能创建
3. 使构造函数 不能被调用
4. 私有化 构造函数

本质：提供静态对象指针， 创建的对象均指向这一个地址 且只能对这一个 静态对象指针进行操作

实现：
1. 私有化 无参构造函数
2. 创建 类的 静态成员指针变量
    - 该成员变量私有化，避免传入空指针的情况
    - 提供返回该变量 的成员函数
3. 类外初始化
4. 私有化 拷贝构造 
    - 拷贝构造创建的对象 具有不同的地址



单例模式类 使用方式:
创建类指针   通过 常函数赋值
Printer *p1 = Printer::getPrinter();