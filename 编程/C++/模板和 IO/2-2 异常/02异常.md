# 02异常
核心思想：
1. 将问题检测和问题处理 分离；
2. 通信思想：问题检测代码抛出对象 给问题处理代码；
3. 通信内容是：出现了什么错误。

简言之：
异常处理是处理程序中的 错误。
错误是指 程序运行过程发生的错误，如：除0溢出，下标越界，读取文件不存在，空指针，内存不足等。


1. 异常作用
2. 异常基本语法、流程
3. 异常的接口声明
4. 栈解旋
5. 异常的声明周期
6. 异常的多态


## C语言处理异常缺陷
1. 返回值意思不明确
2. 只能返回一条信息
3. 返回值可以忽略



## 异常基本语法、流程

### 流程
1. 加入异常代码     —— 异常发生时，不会执行后面代码
2. 抛出异常         —— 抛出异常后结束当前函数
3. 接收异常         —— 从上往下查找

### 基本语法
1. try{异常代码} 
2. throw 数据;    抛出相应类型的异常
3. catch(异常类型){}


使用手册：
1. 使用关键字 加入try、抛出throw、接收catch；
2. 有抛出就必须要 接收处理；
3. 在最后一个 catch 向上抛出   —— 抛给 调用 catch 函数 的函数
4. 由被抛的函数的异常 进行处理；
5. catch(...){}  接收所有没有写的类型异常；


### 应用
1. 抛出对象    —— 可携带多条信息
2. catch  中既可只填类型，也可加上变量名




## 异常严格的类型匹配
异常的类型匹配是严格的；
不存在隐式转换；


## 异常的接口声明
1. 限定抛出的类型
2. 在抛出异常的函数声明后 加上throw(type1,type2..)
3. 在部分编译器不生效；Qt可用



## 栈解旋
1. 为了节省空间；
2. 在异常抛出前，函数对象全部释放。

ps: 抛出的异常调用拷贝构造



## 异常的生命周期
1. 三个对象     —— 函数内创建对象，并抛出该对象。
    1. 对象一，栈解旋：异常接受前释放
    2. 对象二，函数内 拷贝构造
    3. 对象三，catch 函数 拷贝构造
    4. 对象二、三 在catch函数结束时释放
2. 两个对象     —— 抛出匿名对象
3. 一个对象     —— 抛出匿名对象，使用引用接收

注意点：
- 一个对象常用、节省空间

### 用指针接收
- 编译器不允许对 栈中的匿名对象取地址；
- 编译器允许对 栈中的匿名对象取地址； throw new Maker();
- 抛出堆区匿名对象后，可以使用指针接收；
- 需要手动释放对象；



## 异常的多态
1. 接收 使用父类的引用。
2. 从而实现接收一个类型，可以传入不同对象，实现不同效果。

多态实现：
1. 父类有虚函数
2. 继承父类并 重写虚函数
3. 使用父类引用 指向子对象；



## 系统的标准异常类
           
           
### const char* 转 string / string 转 const char*
const char* chr;
string str;
1. const char* -> string : (string)chr;
2. string -> const char* : str.c_str();


### 系统提供的标准异常类
标准异常类头文件：\<stdexcept\>
2013Vs之前版本需要加上。


所有的异常类都有一个what()方法，返回const char\* 类型（C风格字符串）的值，描述异常信息。
**标准异常类的具体描述：**

| <br> | <br> |
| --- | --- |
| 异常名称 | 描述 |
| exception | 所有标准异常类的父类 |
| bad\_alloc | 当operator new and operator new\[\]，请求分配内存失败时 |
| bad\_exception | 这是个特殊的异常，如果函数的异常抛出列表里声明了bad\_exception异常，当函数内部抛出了异常抛出列表中没有的异常，这是调用的unexpected函数中若抛出异常，不论什么类型，都会被替换为bad\_exception类型 |
| bad\_typeid | 使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad\_typeid异常 |
| bad\_cast | 使用dynamic\_cast转换引用失败的时候 |
| ios\_base::failure | io操作过程出现错误 |
| logic\_error | 逻辑错误，可以在运行前检测的错误 |
| runtime\_error  | 运行时错误，仅在运行时才可以检测的错误 |

**logic\_error** **的子类：**

| <br> | <br> |
| --- | --- |
| 异常名称 | 描述 |
| length\_error | 试图生成一个超出该类型最大长度的对象时，例如vector的resize操作 |
| domain\_error | 参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数 |
| out\_of\_range | 超出有效范围 |
| invalid\_argument | 参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常 |

**runtime\_error** **的子类：**

|       <br>        |                                              <br>                                               |
| ----------------- | ----------------------------------------------------------------------------------------------- |
| 异常名称           | 描述                                                                                            |
| range\_error      | 计算结果超出了有意义的值域范围                                                                    |
| overflow\_error   | 算术计算上溢                                                                                     |
| underflow\_error  | 算术计算下溢                                                                                     |
| invalid\_argument | 参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是’0’或’1’的时候，抛出该异常 |